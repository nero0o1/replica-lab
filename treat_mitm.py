import xml.etree.ElementTree as ET
import base64
import json
import os
from collections import defaultdict

def treat_mitm_data(xml_path, output_md):
    print(f"Treating data from {xml_path}...")
    if not os.path.exists(xml_path):
        print(f"Error: {xml_path} not found.")
        return

    try:
        # Using context manager for parsing large XML
        tree = ET.parse(xml_path)
        root = tree.getroot()
        
        endpoints = defaultdict(list)
        
        for item in root.findall('item'):
            method_el = item.find('method')
            path_el = item.find('path')
            url_el = item.find('url')
            
            if method_el is None or path_el is None:
                continue
                
            method = method_el.text
            path = path_el.text
            url = url_el.text if url_el is not None else ""
            
            # Focus on Editor 3 API
            if '/editor/designer/api/' not in path:
                continue
                
            req_el = item.find('request')
            resp_el = item.find('response')
            
            req_body = b""
            if req_el is not None and req_el.text:
                try:
                    if req_el.get('base64') == 'true':
                        req_data = base64.b64decode(req_el.text)
                    else:
                        req_data = req_el.text.encode('utf-8')
                    
                    parts = req_data.split(b'\r\n\r\n', 1)
                    if len(parts) > 1:
                        req_body = parts[1]
                except:
                    pass

            resp_body = b""
            if resp_el is not None and resp_el.text:
                try:
                    if resp_el.get('base64') == 'true':
                        resp_data = base64.b64decode(resp_el.text)
                    else:
                        resp_data = resp_el.text.encode('utf-8')
                        
                    parts = resp_data.split(b'\r\n\r\n', 1)
                    if len(parts) > 1:
                        resp_body = parts[1]
                except:
                    pass

            # Categorize by normalized path (removing IDs)
            import re
            norm_path = re.sub(r'/\d+', '/{id}', path)
            api_key = f"{method} {norm_path}"
            
            if api_key not in endpoints:
                endpoints[api_key] = {
                    'url': url,
                    'samples': []
                }
            
            if len(endpoints[api_key]['samples']) < 3:
                sample = {}
                # Try to clean and parse JSON
                for label, body in [('request', req_body), ('response', resp_body)]:
                    if body.startswith(b'{') or body.startswith(b'['):
                        try:
                            # Clean potential junk before/after JSON
                            body_str = body.decode('utf-8', errors='ignore')
                            json_start = body_str.find('{') if body_str.find('{') != -1 else body_str.find('[')
                            json_end = body_str.rfind('}') if body_str.rfind('}') != -1 else body_str.rfind(']')
                            if json_start != -1 and json_end != -1:
                                sample[label] = json.loads(body_str[json_start:json_end+1])
                        except:
                            pass
                
                if sample:
                    endpoints[api_key]['samples'].append(sample)

        # Generate Markdown
        os.makedirs(os.path.dirname(output_md), exist_ok=True)
        with open(output_md, 'w', encoding='utf-8') as f:
            f.write("# Editor 3 (Flow Forms) - API Technical Inventory\n\n")
            f.write("> [!NOTE]\n")
            f.write("> This documentation was auto-generated by treating intercepted traffic from Burp/MITM captures.\n\n")
            
            f.write("## üõ†Ô∏è Endpoints Map\n\n")
            for api, info in sorted(endpoints.items()):
                f.write(f"### `{api}`\n")
                f.write(f"- **Example URL:** `{info['url']}`\n")
                
                if info['samples']:
                    f.write("#### Data Structures\n\n")
                    for i, s in enumerate(info['samples']):
                        f.write(f"<details><summary>Sample Payload Set {i+1}</summary>\n\n")
                        if 'request' in s:
                            f.write("##### Request Body\n```json\n")
                            f.write(json.dumps(s['request'], indent=2, ensure_ascii=False))
                            f.write("\n```\n")
                        if 'response' in s:
                            f.write("##### Response Body\n```json\n")
                            f.write(json.dumps(s['response'], indent=2, ensure_ascii=False))
                            f.write("\n```\n")
                        f.write("</details>\n\n")
                f.write("---\n\n")

        print(f"Successfully generated: {output_md}")
        return True
    except Exception as e:
        print(f"Error: {e}")
        return False

if __name__ == "__main__":
    xml_path = r'j:\replica_lab\burp_analise\save_all_documento_clinico_V3.xml'
    output_path = r'j:\replica_lab\_contexto\05_EDITOR3_API_SURVEY.md'
    treat_mitm_data(xml_path, output_path)
